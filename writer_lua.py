#! python
# -*- coding:utf-8 -*-

import os
import sys

try:
    basestring
except NameError:
    basestring = str

try:
    long
except NameError:
    long = int

BASE_LENGTH = 120
BASE_INDENT = "    "
INDENT_LIST = {}

class Writer:

    def __init__(self,doc_name,sheet_name):
        self.doc_name   = doc_name
        self.sheet_name = sheet_name

    # 文件后缀
    def suffix(self):
        return ".lua"

    # 获取缩进字符串
    def indent_ctx( self,indent ):
        if indent <= 0: return ""

        if indent not in INDENT_LIST:
            ctx = BASE_INDENT*indent
            INDENT_LIST[indent] = ctx

        return INDENT_LIST[indent]

    # 文件注释，不要带时间，那样在svn里老是需要提交
    def comment(self):
        comment = '--[[\n'
        comment += 'DO NOT MODITY!  Auto generated by py_exceltools\n'
        comment += 'https://www.python.org/\n'
        comment += 'http://www.python-excel.org/\n'
        comment += ']]\n\n'
        return comment

    # dict转换为lua类型
    def dict_to_lua(self,value,indent):
        dict_ctx_list = []

        cur_indent = self.indent_ctx(indent)
        next_indent = self.indent_ctx(indent + 1)
        # 需要对key排序，不然每次导出的字段是乱的，对版本管理不友好
        for k in sorted( value ) :
            k_indent,lk = self.to_lua( k,indent )
            is_indent,lv = self.to_lua( value[k],indent + 1 )

            # key要用[]括起来，防止有数字key
            key = "".join( ["[",lk,"]"] )

            # 子类型有缩进，则必须换行
            if is_indent :
                val = "".join( [key," =","\n",lv] )
            else :
                val = "".join( [key," = ",lv] )

            dict_ctx_list.append( val )

        # dict的话都换行，不换行不好看
        sep = ",\n" + next_indent
        dict_str = sep.join( dict_ctx_list )

        return True,"".join(
            [cur_indent,"{\n",next_indent,dict_str,"\n",cur_indent,"}"])

    # list转换为lua类型
    def list_to_lua(self,value,indent):
        list_ctx_list = []
        cur_indent = self.indent_ctx(indent)
        next_indent = self.indent_ctx(indent + 1)

        total_len = 0
        any_indent = False
        for v in value :
            is_indent,lv = self.to_lua( v,indent + 1 )
            if is_indent : any_indent = True
            if not any_indent and total_len < BASE_LENGTH :
                total_len = total_len + len( lv )

            list_ctx_list.append( lv )

        if any_indent :
            # 子元素是dict或者list并且换了行，则都必须换行
            list_str = ",\n".join( list_ctx_list )
            return True,"".join(
                [cur_indent,"{\n",list_str,"\n",cur_indent,"}"] )
        elif total_len > BASE_LENGTH :
            # 元素太多，一行显示不下，比如策划配置了上千个{a,a,a,a,a,a,a,a,a,a,a,a}
            # 应该自动分行，一行显示合适的个数
            cur_len = 0
            cur_ctx = []
            line_ctx = []
            for ctx in list_ctx_list :
                cur_len = len(ctx)
                cur_ctx.append( ctx )
                if cur_len >= BASE_LENGTH :
                    line_ctx.append( ",".join( cur_ctx ) )
                    cur_len = 0
                    cur_ctx = []
            if any(cur_ctx) : line_ctx.append( ",".join( cur_ctx ) )

            sep = ",\n" + next_indent
            list_str = sep.join( line_ctx )
            return True,"".join(
                [cur_indent,"{\n",next_indent,list_str,"\n",cur_indent,"}"] )
        else :
            # 返回 {a,b,c}这种不换行的格式
            list_str = ",".join( list_ctx_list )
            return False,"".join( ["{",list_str,"}"] )


    # 变量转换到lua字符串
    def to_lua(self,value,indent):
        val_type = type( value )
        if int == val_type :
            return False,str( value )
        elif long == val_type :
            return False,str( value )
        elif float == val_type :
            # 1001.0 -->> 001 去除多余小数点
            if int( value ) == value :
                return False,str( int(value) )
            return False,str( value )
        elif str == val_type :
            # 字符串要用单引号，因为Lua里单引号级别比双引号高
            return False,"".join(["'",value,"'"])
        elif dict == val_type :
            return self.dict_to_lua(value,indent)
        elif list == val_type :
            return self.list_to_lua(value,indent)
        else :
            raise Exception( "invalid type",val_type )

    #文件内容
    def context(self,ctx):
        is_indent,str_ctx = self.to_lua( ctx,0 )

        return "".join( [self.comment(),"return\n",str_ctx] )
